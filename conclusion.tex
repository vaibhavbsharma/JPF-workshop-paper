\section{Conclusion}
%Talk about veritesting is important, but implementing it at the Java bytecode requires solving different research and engineering challenges.
Veritesting provides a way to address the scalability challenges faced by dynamic symbolic execution.
%
Nevertheless, integrating veritesting with symbolic execution at the Java bytecode level presents unique challenges.
%
Our Soot-based analysis of six large open-source Java projects confirms that, while a number of opportunities to apply veritesting arise organically in Java bytecode, the benefit of veritesting can be amplified by adding ``just in time'' support of virtual function invocations and techniques for reducing the number of exit points introduced by exceptions and early return statements.  In addition, careful integration with Symbolic PathFinder is necessary to achieve good performance.
%
%Implementing veritesting with the Symbolic PathFinder motivates robust implementation of expression reuse and introduction of complex expressions.
%
%Using veritesting to its full extent during symbolic execution of Java bytecode requires us to address such research and engineering challenges.
%
%But, veritesting has clear potential to provide significant speed-up to symbolic execution tools such as Symbolic PathFinder.
